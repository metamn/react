{"componentChunkName":"component---src-templates-blog-post-js","path":"/how-to-write-react-code-in2019/","webpackCompilationHash":"24326f45bfad1daac30e","result":{"data":{"site":{"siteMetadata":{"title":":heart: React","author":"Metamn"}},"markdownRemark":{"id":"8abbe10e-3757-52f1-afa3-064034597183","excerpt":"Cory House nails it.","html":"<p><a href=\"https://twitter.com/housecor/status/1185222395210153984?s=20\">Cory House</a> nails it.</p>\n<!--more-->\n<p>Even if there is <a href=\"http://metamn.io/react/there-is-no-official-style-guide-for-react/\">no official style guide</a> to write React code — there are official <a href=\"https://reactjs.org/docs/thinking-in-react.html\">guidelines</a> and <a href=\"https://reactjs.org/docs/hooks-rules.html\">rules</a> to follow, and a common sense emerging from <a href=\"Identify%20the%20right%20leaders\">the leaders</a>.</p>\n<p>In <a href=\"https://www.dropbox.com/s/tsid5bnphznbvjv/Lessons%20learned%20from%205%20years%20in%20React.docx?dl=0\">Lessons learned from 5 years in React</a> Cory House collects his wisdom into one single document. I found it deeply resonating with my practice — and the common sense.</p>\n<p>(With his hopefully mutual permission) I’m replicating the document as checkboxes to see those points I’ve met, and the ones where I might catch up.</p>\n<p>You can do the same exercise too by <a href=\"https://github.com/metamn/react/blob/master/content/blog/how-to-write-react-code-in2019/index.md\">forking the list</a> from the source code of this article.</p>\n<h3>Getting familiar with a new project</h3>\n<ol>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Review package.json first to understand deps, scripts, and config.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Draw tree on the whiteboard, or use React dev tools. Helps to visualize state.</li>\n</ol>\n<h3>Dev workflow</h3>\n<ol start=\"3\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Quickly nav to component or func: CMD click in JSX (VSCode)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Quickly nav to parent: CMD+SHIFT+F to Search for &#x3C;ComponentName (VSCode)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Quickly view list of parents: Use React dev tools</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Create a component state checklist. Use it for every component. (error, no data, lots of data, long values, full list here)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Debugging? type debugger. console.assert also handy.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Work against mock data and mock API (I like json-server, json-graphql-server)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Centralize mock data for Storybook, tests, and mock API.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Pass an object to a function and destructure to create named parameters. Reads more clearly. And can destructure in the function signature too. This keeps the calls in the func short and documents the expected object properties.</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled> Storybook driven development – Build and test each component in isolation. Document each state in a separate story. Then use Percy or Chromatic to snapshot.</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Knobs</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Responsive design</li>\n</ul>\n</li>\n</ol>\n<h3>JSX</h3>\n<ol start=\"12\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled> You can only write expressions within a return. This limits what you can do in JSX. Options:</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Return early. (good for loaders and errors)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Extract a separate function from render when you want the full power of JavaScript (if/else/switch)</li>\n</ul>\n</li>\n</ol>\n<h3>Performance</h3>\n<ol start=\"13\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Do the most convenient thing. It’ll probably be fast enough. Inline func? Fine. Worried about renders? Don’t be. Worried about context performance? Okay, then maybe you’re misusing context (should rarely change). Sure, perf test (set Chrome perf to 6x), but don’t speculate. Degrade ergonomics after establishing a perf issue.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Remember, a render != DOM change. With virtual DOM, the diff is in-memory. Flow: render -> reconcile -> commit. If the DOM doesn’t change, there’s likely no perf issue. So stop worrying about needless re-renders. React is smart enough to only change the DOM when needed, so it’s typically fast enough. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Don’t slap useMemo, shouldComponentUpdate, PureComponent everywhere. Only where needed. They have overhead because it’s an extra diff. If they were typically faster, they’d be the default!</li>\n</ol>\n<h3>State management</h3>\n<ol start=\"16\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Keep state as low as you can. Lift when needed.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Avoid state that can be derived. Calc on the fly. Reference objects by id instead of duplicating.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use _myVar convention to resolve state naming conflicts.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Don’t sync state, derive it. Example, calculate full name on the fly by concatenating firstName and lastName in render. Don’t store fullName separately. Doing so risks out of sync issues and requires extra code to keep it in sync.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> State that changes together, should live together. Reducers help. So does grouping via useState. Consider state machines – they describe valid states, which makes invalid state impossible (as new customer with 5 previous purchases, or an admin with no rights shouldn’t be possible. If separate states, they can get outta sync)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Probably don’t need Redux. Lifting state scales nicely and is easy to understand. Prop drilling pain is overblown. Keep prop names the same. Spread props. Pass child. Memoize. Use context and useReducer cover the rare global needs well. Show slides of diff data approaches from my updated Redux course.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Context isn’t just useful for global data. Useful for compound components. Can be useful for performance. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> setLoading(false) in finally to assure it’s called</li>\n</ol>\n<h3>Props</h3>\n<ol start=\"24\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Require all props at first</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Destructure props in func signature to shorten calls below. Useful on event handler funcs too. But what about props with dashes in name like aria-label? Well, don’t destructure that by using spread: …otherProps</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Make your props as specific as possible</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Standardize naming. onX for eventHandler props. handleX for the func.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Centralize your propTypes</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Document propTypes via JSDoc style comments = autocomplete and docs in Storybook. Can even use markdown!</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Spread props or pass children to reduce the pain of prop drilling</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Prop existence conveys truth. So <code class=\"language-text\">&lt;Input required /&gt;</code> is sufficient. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Honor the native API in your reusable component designs. Pass the full event to event handlers, not merely the value. Then you can use a centralized change handler. Honor the native names (onBlur, onChange, etc). Doing so maximizes flexibility and minimizes the learning curve.</li>\n</ol>\n<h3>Styling</h3>\n<blockquote>\n<p>Note: Here I have a completely different approach based on <code class=\"language-text\">styled-components</code> best practices and inspired by Material UI.</p>\n</blockquote>\n<ol start=\"33\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled> Mix styling approaches. </p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Inline styles for dynamic styles. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Namespace via CSS modules.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use plain Sass for global styles.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> CSS in JS remains a hard sell – too many horses in the race. </li>\n</ul>\n</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use classnames to apply multiple styles</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Use flexbox and CSS Grid over floating styles</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Create abstraction over flexbox to abstract breakpoints for consistency (bootstrap gives ya this) </li>\n</ol>\n<h3>Reusable components</h3>\n<ol start=\"37\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> 3 keys to easy reuse</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Consider dedicating a person/team to this. Why? Speed. Less decision fatigue. Smaller bundles. Consistency = better UX. Less code = fewer bugs.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Look for repeated code – opportunity for reuse. Every reuse is a perf enhancement.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> DRY out your forms by combining custom hooks, context, and reusable components to create an opinionated custom approach that encapsulates your app’s business rules. These tools are the foundation.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Accept both a simple string and an element. Use React.isValidElement to tell which you’re getting.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Create an “as” prop to specify the top-level element.  </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Create a reusable AppLayout using the slot pattern.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Centralize alerts in AppLayout and provide function for showing the alerts via context.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Gen custom docs via react-docgen</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Consider creating separate mobile and desktop components if they differ significantly. Lazy load the relevant size. </li>\n</ol>\n<h3>Testing</h3>\n<ol start=\"47\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Prefer RTL over Enzyme. Simpler API = pit of success. Encourages a11y. Easy to debug. Can use same queries for Cypress.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> JSDOM doesn’t render, so can’t test responsive design there. Use Cypress to test responsive design behavior.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Avoid Jest snapshot tests. They’re brittle, they test implementation details, they’re often poorly named, they all fail when a single line changes, and they’re hard to fix when they fail. Instead, prefer Percy or Chromatic to test visuals</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use the scenario selector pattern to run your app against different data. Automate these tests via Cypress/Selenium</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use Cypress testing library so your Cy selectors match your React Testing library selectors = No need to change code to support Cypress tests!</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Cypress driven development – TDD for integration testing. Use Cypress to navigate to the spot you need to test. Use cy.only to call a single test. It should fail first. Make it pass. </li>\n</ol>\n<h3>Dev env</h3>\n<ol start=\"53\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled> Consider customizing create-react-app (CRA). </p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use react-app-rewired to tweak the config without ejecting </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Customize linting rules. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Add webpack-bundle-analyzer. Know what’s in your bundle. </li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Consider forking at least react scripts. Consider forking CRA. Create a company framework that generates a project with a single dependency: Your react-scripts fork that includes your company’s components, tweaks, dependencies, linting rules, webpack.config, etc.  </li>\n</ul>\n</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Use Prettier. Convert in one big commit. You’ll look like the hero!</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Lean on ESLint. Use as a teaching tool. Object shorthand. No var. Disallow certain imports (jquery, lodash, moment). Require triple equals. Don’t form a committee. Assign someone you trust and enable a lot of good stuff. Can always back off later. Add plugins like jsx-a11y/recommended.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Require strict propTypes (or TS). I don’t get many type issues. (see link for list)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use .vsextensions to encourage extensions.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Keep client and server separate. If embedding React in a server-side tech, use Storybook to develop components in isolation.</li>\n</ol>\n<h3>Consider a monorepo</h3>\n<ol start=\"59\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Why? Rapid feedback. Continuous integration.</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Easy reuse</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> CI integration tests projects on every PR</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Use Lerna, Bolt, Yarn Workspaces, or even simply a relative file reference to your reusable components to manage. I typically use Lerna.</li>\n</ol>\n<h3>Learning</h3>\n<ol start=\"63\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Have a system for organizing your knowledge. Find a new tool? Technique? Document it. I use GitHub issues here on my reactjsconsulting repo.</li>\n</ol>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"http://metamn.io/react/there-is-no-official-style-guide-for-react/\">There is no official style guide for React</a></li>\n<li><a href=\"http://metamn.io/react/identify-the-right-leaders/\">Identify the right leaders</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-rules.html\">Rules of Hooks</a></li>\n<li><a href=\"https://reactjs.org/docs/thinking-in-react.html\">Thinking in React</a></li>\n<li><a href=\"https://www.dropbox.com/s/tsid5bnphznbvjv/Lessons%20learned%20from%205%20years%20in%20React.docx?dl=0\">Lessons learned from 5 years in React</a></li>\n</ul>","frontmatter":{"title":"How to write React code in 2019","date":"October 20, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/how-to-write-react-code-in2019/","previous":{"excerpt":"React and the ecosystem mapped up.","fields":{"slug":"/a-big-picture/"},"frontmatter":{"title":"A Big Picture"}},"next":{"excerpt":"22 things in random order.","fields":{"slug":"/things-ive-learnt-q4-2019/"},"frontmatter":{"title":"Things I've learnt — Q4 2019"}}}}}