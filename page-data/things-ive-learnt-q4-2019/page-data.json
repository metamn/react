{"componentChunkName":"component---src-templates-blog-post-js","path":"/things-ive-learnt-q4-2019/","webpackCompilationHash":"836be8b29b9408fabb78","result":{"data":{"site":{"siteMetadata":{"title":":heart: React","author":"Metamn"}},"markdownRemark":{"id":"31a9193d-ad9d-5267-9d1b-3f6aa87fec2f","excerpt":"22 things in random order.","html":"<p>22 things in random order.</p>\n<!--more-->\n<h2>Mirage - Mocking APIs</h2>\n<ul>\n<li><a href=\"https://miragejs.com/\">https://miragejs.com/</a></li>\n<li>Build complete frontend features, even if your API doesn’t exist.</li>\n</ul>\n<h2>TLA+, Alloy - Verify requirements with formal methods</h2>\n<ul>\n<li><a href=\"https://www.hillelwayne.com/post/business-case-formal-methods/\">https://www.hillelwayne.com/post/business-case-formal-methods/</a></li>\n<li>Test requirements for bugs and incompleteness before anything else</li>\n</ul>\n<h2>TypeScript is not a sound type system</h2>\n<ul>\n<li><a href=\"https://blog.logrocket.com/is-typescript-worth-it/\">https://blog.logrocket.com/is-typescript-worth-it/</a></li>\n<li>A sound type system is one that ensures your program does not get into invalid states.</li>\n<li>Typescript is entirely upfront about the fact that 100% soundness is not a goal</li>\n</ul>\n<h2>Parallelized Decision Making</h2>\n<ul>\n<li><a href=\"https://arkwright.github.io/parallelized-decision-making.html\">https://arkwright.github.io/parallelized-decision-making.html</a></li>\n<li>Doing Things In Serial Is Slower Than Doing Them In Parallel</li>\n</ul>\n<h2>Event sourcing and microservices are hard</h2>\n<ul>\n<li><a href=\"https://arkwright.github.io/event-sourcing.html\">https://arkwright.github.io/event-sourcing.html</a></li>\n<li>But don’t dive in, because you’ll probably drown</li>\n<li>Incorporate this pattern into a portion of your project — get your feet wet.</li>\n</ul>\n<h2>Immutable.js - Functional Javascript from Facebook</h2>\n<ul>\n<li><a href=\"https://www.freecodecamp.org/news/immutable-js-is-intimidating-heres-how-to-get-started-2db1770466d6/\">https://www.freecodecamp.org/news/immutable-js-is-intimidating-heres-how-to-get-started-2db1770466d6/</a></li>\n<li>A library used by Facebook to replace native Javascript constructs (array, object, …) with functional counterparts (list, map)</li>\n</ul>\n<h2>QuickCheck: Property Based Testing in Javascript (aka auto-generated test inputs covering [hundreds of] edge cases)</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=_2tK9G7rKQQ&#x26;t=1006s\">https://www.youtube.com/watch?v=_2tK9G7rKQQ&#x26;t=1006s</a></li>\n<li><a href=\"https://marmelab.com/blog/2019/04/18/property-based-testing-js.html\">https://marmelab.com/blog/2019/04/18/property-based-testing-js.html</a></li>\n<li>Property based testing is a technique widely used in the Haskell community, using a tool such as QuickCheck. The idea consists in automatically generating inputs for testing a function.</li>\n</ul>\n<h2>Expo supports all platforms</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=ykBxY01j_rA\">https://www.youtube.com/watch?v=ykBxY01j_rA</a></li>\n<li>Build for web, deploy everywhere native</li>\n</ul>\n<h2>Executable requirement specifications</h2>\n<ul>\n<li><a href=\"http://agilemodeling.com/essays/executableSpecifications.htm\">http://agilemodeling.com/essays/executableSpecifications.htm</a></li>\n<li><a href=\"https://cucumber.io/\">https://cucumber.io/</a></li>\n</ul>\n<h2>UI Before API</h2>\n<ul>\n<li><a href=\"https://overreacted.io/what-are-the-react-team-principles/\">https://overreacted.io/what-are-the-react-team-principles/</a></li>\n</ul>\n<h2>Proptypes should be immutable</h2>\n<ul>\n<li>Proptypes can be chained up (the parent imports the children proptypes and default props) in React but makes Storybook crash randomly</li>\n<li>With import proptypes lose their immutability, their structure becomes dynamic (depending on children proptypes) instead of being static (hand written; children proptypes copy/pasted into parent proptypes)</li>\n<li>Neither approach is ok => there is a need for a data layer (<code class=\"language-text\">Component.data.js</code>) which imports children proptypes and generates static proptypes for the parent</li>\n</ul>\n<h2>AirBnb custom Proptypes</h2>\n<ul>\n<li><a href=\"https://github.com/airbnb/prop-types\">https://github.com/airbnb/prop-types</a></li>\n<li>extends the standard Proptypes with new validators</li>\n</ul>\n<h2>Describing data and services (API) with standards is in infancy</h2>\n<ul>\n<li>We saw at “Proptypes should be immutable” that we need a data layer independent of the Proptypes syntax (or even TypeScript or anything else)</li>\n<li>For that a standard approach (JSON-LD, Schema.org) should be used like <a href=\"https://json-schema.org/\">https://json-schema.org/</a>, <a href=\"https://en.wikipedia.org/wiki/Overview_of_RESTful_API_Description_Languages\">https://en.wikipedia.org/wiki/Overview_of_RESTful_API_Description_Languages</a>, <a href=\"https://www.markus-lanthaler.com/hydra/\">https://www.markus-lanthaler.com/hydra/</a></li>\n<li>More, not just data but also the services should be described with machine-readable standards: <a href=\"https://www.sciencedirect.com/science/article/pii/S1877050918316302\">https://www.sciencedirect.com/science/article/pii/S1877050918316302</a></li>\n<li>Which is not yet possible:</li>\n</ul>\n<blockquote>\n<p>Although there has been a vast amount of effort in the semantic web services field, the approaches did not gain too much adoption outside of academia, mainly due to lack of concrete incentives and steep learning curves.</p>\n</blockquote>\n<h2>Co-location pays off</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Component.js - the main file\nComponent.features.js - the requirements as executable specifications\nComponent.tests.js - tests\nComponents.stories.js - Storybook tests\nComponent.data.js - data types (for special cases)\nComponent.css.js - styles (for special cases)\nComponent.md - documentation\nComponent.api.md - api doc generated from code comments\nComponent.lang.xx-xx.js - internationalization\n...</code></pre></div>\n<h2>Split components into independent modules</h2>\n<ul>\n<li>Even in a relatively small app (SAAS providing searching/filtering information) the number of components can grow up around 100</li>\n<li>To reduce <code class=\"language-text\">/components</code> complexity we can split it into <code class=\"language-text\">/components/saas</code> and <code class=\"language-text\">/components/search</code> since both of them are standalone (even reusable) modules</li>\n<li>Clear separation means all components inside a module are importing components from the same module only. For example <code class=\"language-text\">/saas/pricing</code> component imports components only from <code class=\"language-text\">/saas</code> and no components from <code class=\"language-text\">/search</code>.</li>\n</ul>\n<h2>Cucumber.io is the Github for tests</h2>\n<ul>\n<li><a href=\"https://cucumber.io/\">https://cucumber.io/</a></li>\n<li>It hosts and manages your tests as Github does your code</li>\n</ul>\n<h2>Refactoring - The rule of 3</h2>\n<ul>\n<li>One needs at least 3 use cases before refactoring code / extracting reusable parts / trying to generalize a solution</li>\n</ul>\n<h2>shortid - For list keys in React</h2>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/shortid\">https://www.npmjs.com/package/shortid</a></li>\n<li>Never use <code class=\"language-text\">index</code> from <code class=\"language-text\">map</code> for <code class=\"language-text\">key</code>. Use instead the <code class=\"language-text\">shortid</code> package.</li>\n<li><a href=\"https://reactjs.org/docs/lists-and-keys.html#keys\">https://reactjs.org/docs/lists-and-keys.html#keys</a></li>\n<li><a href=\"https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318\">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a></li>\n</ul>\n<h2>Skeletons and strategies for React hooks</h2>\n<ul>\n<li><a href=\"http://www.passportjs.org/\">Passport.js</a> offers a nice authentication solution: there is a general workflow where 500+ custom strategies can be inserted.</li>\n<li>This skeleton / strategy pattern was found useful in other scenarios like data fetching (<a href=\"https://github.com/metamn/use-data\">https://github.com/metamn/use-data</a>) and even porting the Passport.js idea to the React frontend (<a href=\"https://github.com/metamn/use-auth\">https://github.com/metamn/use-auth</a>)</li>\n</ul>\n<h2>JSON form generators are all buggy</h2>\n<ul>\n<li>See <a href=\"https://github.com/metamn/react-forms\">https://github.com/metamn/react-forms</a></li>\n<li>Tested <code class=\"language-text\">react-jsonschema-form</code>, <code class=\"language-text\">uniforms</code>, Final Form, Formik and more</li>\n</ul>\n<h2><code class=\"language-text\">react-admin</code> useful only for CRUD resources</h2>\n<ul>\n<li><a href=\"https://marmelab.com/react-admin/\">https://marmelab.com/react-admin/</a></li>\n<li>When you have non-crud resources lots of overwriting is needed and won’t worth it</li>\n</ul>\n<h2>Bit.dev is the Github for React packages</h2>\n<ul>\n<li><a href=\"https://bit.dev/\">https://bit.dev/</a></li>\n<li>Package any React component and clone it, fork it, pull it, push it like code on Github.</li>\n</ul>","frontmatter":{"title":"Things I've learnt — Q4 2019","date":"January 28, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/things-ive-learnt-q4-2019/","previous":{"excerpt":"React and the ecosystem mapped up.","fields":{"slug":"/a-big-picture/"},"frontmatter":{"title":"A Big Picture"}},"next":{"excerpt":"React—used appropriately—works.","fields":{"slug":"/things-ive-learnt-in-2020/"},"frontmatter":{"title":"Things I've learnt in 2020"}}}}}